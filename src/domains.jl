abstract type AbstractDomain{DIM} end

"""
    IntervalDomain{DIM, F}

A domain defined by a lower and upper bound for each dimension.
The lower and upper bounds are represented as vectors of length `DIM`.
The type parameter `F` represents the element type of the bounds.
"""
struct IntervalDomain{DIM,F} <: AbstractDomain{DIM}
    lo::SVector{DIM,F}
    hi::SVector{DIM,F}
    function IntervalDomain(lo::AbstractVector, hi::AbstractVector)
        @assert length(lo) == length(hi)
        @assert all(lo .<= hi)
        D = length(lo)
        F = eltype(lo)
        return new{D,F}(lo, hi)
    end
end


"""
    in_domain(domain::IntervalDomain{DIM, F}, y::SVector{DIM, F}) where {DIM, F}

Check if a point `y` is within the bounds defined by the `domain`.
Returns `true` if `y` is within the bounds, otherwise returns `false`.
"""
function in_domain(domain::IntervalDomain{DIM,F}, y::SVector{DIM,F}) where {DIM,F}
    for i = 1:DIM
        if !(domain.lo[i] <= y[i] <= domain.hi[i])
            return false
        end
    end
    return true
end


"""
    sample_pair(domain::IntervalDomain{DIM, F}, δ) where {DIM, F}

Sample a pair of points `(x, y)` from the `domain` such that `y` is within a distance `δ` from `x`.
The point `x` is sampled uniformly from the domain, and `y` is generated by adding a random
direction vector scaled by `δ` to `x`.
"""
function sample_pair(domain::IntervalDomain{DIM,F}, δ) where {DIM,F}

    lo = domain.lo
    hi = domain.hi

    while true
        # uniformly sample from the domain
        x = lo + (hi - lo) .* (@SVector rand(DIM))

        # get a direction vector 
        v = δ * rand() * normalize((@SVector randn(DIM)))
        y = x + v

        if in_domain(domain, y)
            return x, y
        end
    end

end
